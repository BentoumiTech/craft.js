(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{181:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return p}));var o=n(47),a=n(207),r=(n(0),n(208)),i=(n(210),{id:"user-components",title:"User Components"}),l={id:"version-0.1.0-beta.17/concepts/user-components",title:"User Components",description:"User Components are intended to be written just like any other React Component.",source:"@site/versioned_docs/version-0.1.0-beta.17/concepts/user-components.md",permalink:"/r/docs/concepts/user-components",version:"0.1.0-beta.17",sidebar:"version-0.1.0-beta.17/docs",previous:{title:"Nodes",permalink:"/r/docs/concepts/nodes"},next:{title:"Interacting with the Editor",permalink:"/r/docs/concepts/editor-components"}},c=[{value:"Connectors",id:"connectors",children:[]},{value:"Props manipulation",id:"props-manipulation",children:[]},{value:"Collecting Node&#39;s state",id:"collecting-nodes-state",children:[]},{value:"Default Props",id:"default-props",children:[]},{value:"Specify drag/drop rules",id:"specify-dragdrop-rules",children:[]},{value:"Related Components",id:"related-components",children:[]},{value:"Defining editable elements",id:"defining-editable-elements",children:[]}],s={rightToc:c};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"User Components are intended to be written just like any other React Component. "),Object(r.b)("p",null,"Let's start with a simple Text component:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'const Text = ({text, fontSize}) => {\n  return (\n    <span contenteditable="true" style={{fontSize}}>{text}</span>\n  )\n}\n')),Object(r.b)("p",null,"Now, let's actually get the component to work with the editor. The ",Object(r.b)("inlineCode",{parentName:"p"},"useNode")," hook provides us with several information and methods related to the corresponding ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," that manages the component."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const { connectors: {connect, drag}, setProp, ...collected } = useNode((node) => {});\n")),Object(r.b)("p",null,"Additionally we can pass configuration values via the static ",Object(r.b)("inlineCode",{parentName:"p"},"craft")," property:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const Text = () => {...}\nText.craft = {\n  props: {},\n  rules: {\n    canDrop: () => true,\n    canDrag: () => true,\n    canMoveIn: () => true,\n    canMoveOut: () => true\n  },\n  related: {}\n}\n")),Object(r.b)("p",null,"We'll explore each of these values in the following sections."),Object(r.b)("h2",{id:"connectors"},"Connectors"),Object(r.b)("p",null,"The first thing we would want to do is to actually let Craft.js to manage the DOM for our component. "),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"connect"),": specifies the DOM that represents the User Component.  If the component's corresponding Node is a Canvas, then this also defines the area that is droppable."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"drag"),": specifies the DOM element that should be made draggable. When the user drags this element, it'll be considered as dragging the entire component, therefore moving the entire component to the drop location. This connector only takes effect if the component's corresponding node is a Canvas Node.")),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{14,15,18}","{14,15,18}":!0}),"const Container = ({children}) => {\n  const { connectors: {connect, drag} } = useNode();\n  return (\n    <div ref={dom => connect(drag(dom))}>\n      {children}\n    </div>\n  )\n}\n\nconst App = () => {\n  return (\n    <Editor resolvers={{Container}}>\n      <Frame>\n        <Element is={Container} canvas> // (i)\n          <Container> // (ii)\n            <h2>Hi</h2>\n          </Container>\n          <Element is={Container} canvas> // (iii)\n            <h2>Hi</h2>\n          </Element>\n        </Element>\n      </Frame>\n    </Editor>\n  )\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"i. ",Object(r.b)("inlineCode",{parentName:"li"},"Element")," is being rendered with a Canvas Node, thus it defines a droppable region. However, since it is not a child of a Canvas Node, it is not draggable (the ",Object(r.b)("inlineCode",{parentName:"li"},"drag")," handler will not do anything)."),Object(r.b)("li",{parentName:"ul"},"ii. ",Object(r.b)("inlineCode",{parentName:"li"},"Container")," is an immediate child of a Canvas Node; it is draggable."),Object(r.b)("li",{parentName:"ul"},"iii. ",Object(r.b)("inlineCode",{parentName:"li"},"Element")," is an immediate child of a Canvas Node and is rendered with a Canvas Node - it is both draggable and droppable.")),Object(r.b)("h2",{id:"props-manipulation"},"Props manipulation"),Object(r.b)("p",null,"You've probably seen page editors where you could directly interact with the components and manipulate them. For instance, drag to resize an image or visually edit a text. This is easily achievable with Craft.js as well."),Object(r.b)("p",null,"Since components are managed by their corresponding ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," which contains information including the component's props, thus we can call the ",Object(r.b)("inlineCode",{parentName:"p"},"setProp")," method to update the prop values stored in the ",Object(r.b)("inlineCode",{parentName:"p"},"Node"),". In turn, this will re-render the component with its updated values."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{2,6-8}","{2,6-8}":!0}),"const Text = ({text, fontSize}) => {\n  const { connectors: {connect, drag}, actions: {setProp} } = useNode();\n\n  return (\n    <span ref={dom => connect(drag(dom))} style={{fontSize}} onKeyUp={(e) => {\n        setProp(props => {\n          props.text = e.target.innerText;\n        })\n      }}>{text}\n    </span>\n  )\n}\n")),Object(r.b)("p",null,"In the above example, we have updated our ",Object(r.b)("inlineCode",{parentName:"p"},"span")," element to be content editable and added an event handler to update the ",Object(r.b)("inlineCode",{parentName:"p"},"text")," prop as the user visually enters in a new value."),Object(r.b)("h2",{id:"collecting-nodes-state"},"Collecting Node's state"),Object(r.b)("p",null,"The information stored in a corresponding ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," could be useful in helping you build more usable components. We can retrieve information from a ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," by passing a collector function to the ",Object(r.b)("inlineCode",{parentName:"p"},"useNode")," hook. Every time the values we retrieved via the collector function changes, our component will re-render. This is very much similar to Redux's ",Object(r.b)("inlineCode",{parentName:"p"},"connect")," pattern."),Object(r.b)("p",null,"For instance, let's say we would like to enable the content editable text from the previous section only when the user has actually clicked on our component: "),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const Text = ({text, fontSize}) => {\n  // highlight-next-line\n  const { connectors: {connect, drag}, setProp, isClicked } = useNode((node) => ({\n    // highlight-next-line\n    isClicked: node.events.selected\n  }));\n\n  return (\n    // highlight-next-line\n    <span ref={dom => connect(drag(dom))} style={{fontSize}} contentEditable={isClicked} onKeyUp={(e) => {\n        setProp(props => {\n          props.text = e.target.innerText;\n        })\n      }}>{text}\n    </span>\n  )\n}\n")),Object(r.b)("h2",{id:"default-props"},"Default Props"),Object(r.b)("p",null,"While it's not necessary as we could simply define default parameters (e.g.: ES6 defaults) directly within our components, these default values will not actually be recorded into the component's corresponding ",Object(r.b)("inlineCode",{parentName:"p"},"Node"),", which could leave us with a lot of empty prop values when we wish to retrieve the ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," for a component when building other parts of our editor (eg: a Toolbar for editing a component's values)."),Object(r.b)("p",null,"To prevent that, we can explicitly specify default prop values via the ",Object(r.b)("inlineCode",{parentName:"p"},"craft.props")," like the following:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'const Text = ({text, fontSize}) => { /** same as previous example **/ }\nText.craft = {\n  props: {\n    text: "Hi there!",\n    fontSize: 12\n  }\n}\n')),Object(r.b)("h2",{id:"specify-dragdrop-rules"},"Specify drag/drop rules"),Object(r.b)("p",null,"You may want to restrict how your components are dragged or what goes in and out of your component. These rules can be specified in the static ",Object(r.b)("inlineCode",{parentName:"p"},"craft.rules"),"."),Object(r.b)("p",null,"Let us write a (pretty strange) rule for our Text component which users can only drag if they change the ",Object(r.b)("inlineCode",{parentName:"p"},"text"),' prop to "Drag": '),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'const Text = ({text, fontSize}) => { /** same as the previous example **/ }\nText.craft = {\n  props: { /** same as the previous example **/ },\n  rules: {\n    canDrag: (node) => !!node.data.props.text == "Drag"\n  }\n}\n')),Object(r.b)("h2",{id:"related-components"},"Related Components"),Object(r.b)("p",null,"What happens if you need to design some component to complement our  user component? For instance, if we were planning on building a Toolbar somewhere in our page editor, we would like the Toolbar to display a bunch of text inputs to allow the user the edit the currently selected component. It would be great if we could retrieve a specific component that has all the relevant inputs for the user to edit the currently selected component."),Object(r.b)("p",null,"This is where related components become useful. These components share the same corresponding ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," as the actual user component, hence the ",Object(r.b)("inlineCode",{parentName:"p"},"useNode")," hook that we have been using all this while will be made available to these components as well. "),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'const Text = ({text, fontSize}) => { /** same as the previous example **/ }\nText.craft = {\n  related: {\n    toolbar: TextToolbarSettings\n  }\n}\n\nconst TextToolbarSettings = () => {\n  const { setProp, fontSize } = useNode((node) => ({\n    fontSize: node.data.props.fontSize\n  }));\n\n  return (\n    <div>\n      <h2>Text settings</h2>\n      <input \n        type = "number" \n        value={fontSize} \n        placeholder="Font size"\n        onChange={e => \n          setProp(prop => prop.fontSize = e.target.value) \n        }\n       />\n    </div>\n  )\n}\n')),Object(r.b)("p",null,"Now, let's say we have a Toolbar component somewhere in our editor. We can easily retrieve the related component as such:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const Toolbar = () => {\n  const { selectededNodeId, toolbarSettings } = useEditor((state) => ({\n    selectededNodeId : state.event.selected,\n    toolbarSettings:  state.nodes[state.events.selected].related.toolbar\n  }));\n  return (\n    <div>\n      <h2>My Awesome Toolbar</h2>\n      {\n        selectededNodeId && toolbarSettings ? \n          React.createElement(toolbarSettings)\n        : null\n      }\n    </div>\n  )\n}\n\n")),Object(r.b)("h2",{id:"defining-editable-elements"},"Defining editable elements"),Object(r.b)("p",null,"Now, let's say we are creating a new User Component like so:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const Hero = ({background}) => {\n  return (\n    <div style={{ background }}>\n      <span>Hero Title</span>\n    </div>\n  )\n}\n")),Object(r.b)("p",null,"Then, we decide that we want to have the ",Object(r.b)("inlineCode",{parentName:"p"},"span")," element to be editable independent of the Text user component we made earlier."),Object(r.b)("p",null,"Your first instinct might be to just use the Text component directly:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{4}","{4}":!0}),'const Hero = ({background}) => {\n  return (\n    <div style={{ background }}>\n      <Text text="Hero Title" />\n    </div>\n  )\n}\n')),Object(r.b)("p",null,"But this won't really work the way we want it to - the Text Component will not have its own Node. Instead, it will still be a part of Hero's Node. So, inside the Text Component, when we call ",Object(r.b)("inlineCode",{parentName:"p"},'setProps(props => props.text = "...")'),", it will actually be editing the props of ",Object(r.b)("inlineCode",{parentName:"p"},"Hero"),". In this case, it will be adding a new prop ",Object(r.b)("inlineCode",{parentName:"p"},"text")," to Hero, which is not consumed by Hero and therefore makes no sense."),Object(r.b)("p",null,"So how do we even define new Nodes inside a User Component? Previously, we discussed how ",Object(r.b)("inlineCode",{parentName:"p"},"<Element />")," is used to define Nodes; that concept is applied universally in Craft.js. Hence, we just have to wrap our ",Object(r.b)("inlineCode",{parentName:"p"},"<Text />")," element in the example above with ",Object(r.b)("inlineCode",{parentName:"p"},"<Element />"),". "),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{4}","{4}":!0}),'const Hero = ({background}) => {\n  return (\n    <div style={{ background }}>\n      <Element is={Text} text="Hero Title" id="title_text" />\n    </div>\n  )\n}\n')),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"You must specify the ",Object(r.b)("inlineCode",{parentName:"p"},"id")," prop of ",Object(r.b)("inlineCode",{parentName:"p"},"<Element />")," when used inside a User Component")),Object(r.b)("p",null,"In the above example, we used ",Object(r.b)("inlineCode",{parentName:"p"},"<Element />")," to create and configure a new Node inside our User Component. We call these Linked Nodes since they are linked to a parent Node via an arbitrary ",Object(r.b)("inlineCode",{parentName:"p"},"id"),". In this case, the ",Object(r.b)("inlineCode",{parentName:"p"},"Text")," node is linked to the ",Object(r.b)("inlineCode",{parentName:"p"},"Hero"),' node via its "title_text" id.'),Object(r.b)("p",null,"Similarly, we could also create a droppable region inside a User Component via a Canvas Node:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{5-7}","{5-7}":!0}),'const Hero = ({background}) => {\n  return (\n    <div style={{ background }}>\n      <Element is={Text} text="Hero Title" id="title_text" />\n      <Element canvas is="section" id="droppable_container">\n        <h2>I\'m dropped here for now</h2>\n      </Elemnet>\n    </div>\n  )\n}\n')))}p.isMDXComponent=!0},207:function(e,t,n){"use strict";function o(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}n.d(t,"a",(function(){return o}))},208:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return m}));var o=n(0),a=n.n(o);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=a.a.createContext({}),p=function(e){var t=a.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=a.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),d=p(n),u=o,m=d["".concat(i,".").concat(u)]||d[u]||b[u]||r;return n?a.a.createElement(m,l(l({ref:t},s),{},{components:n})):a.a.createElement(m,l({ref:t},s))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<r;s++)i[s]=n[s];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},209:function(e,t,n){"use strict";var o=n(0),a=n(48);t.a=function(){return Object(o.useContext)(a.a)}},210:function(e,t,n){"use strict";var o=n(0),a=n.n(o),r=function(e){var t=e.item,n=t[0],o=t.length>1&&"string"==typeof t[1]&&t[1],r=3==t.length?"string"==typeof t[2]&&t[2]:4==t.length&&"string"==typeof t[3]&&t[3],l=t.length>1&&Array.isArray(t[t.length-1])&&t[t.length-1];return a.a.createElement("li",{className:"api-item"},a.a.createElement("div",null,n&&a.a.createElement("code",{className:"api-title"},n),o&&a.a.createElement("strong",{className:"api-type"},o)),r&&a.a.createElement("div",{className:"api-description",dangerouslySetInnerHTML:{__html:r}}),l&&a.a.createElement(i,{items:l}))},i=function(e){var t=e.items;return a.a.createElement("ul",null,t&&t.map((function(e,t){return a.a.createElement(r,{item:e,key:t})})))},l=function(e){var t,n=e.type,o=e.title,r=void 0===o||o,i=e.noMargin,l=void 0===i||i;switch(n){case"hoc":t="Higher-Order Component";break;default:t=n[0].toUpperCase()+n.substring(1)}return a.a.createElement("div",{className:"badge-wrapper"},a.a.createElement("span",{className:"badge badge-"+n+" "+(r?"badge-title":"")+" "+(l?"badge-no-margin":"")},t))},c=n(209),s=function(e){var t=e.img,n=Object(c.a)().siteConfig.baseUrl;return a.a.createElement("div",{className:"img-wrapper"},a.a.createElement("div",null,a.a.createElement("header",null,a.a.createElement("div",null),a.a.createElement("div",null),a.a.createElement("div",null)),a.a.createElement("img",{src:n+"img/"+t})))};n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return l})),n.d(t,"b",(function(){})),n.d(t,"c",(function(){return s}))}}]);