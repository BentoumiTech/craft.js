{"version":3,"file":"static/webpack/static/development/pages/index.js.c57b677831710ddcebed.hot-update.js","sources":["webpack:////Users/prevwong/Documents/GitHub/react-page-builder/node_modules/@craftjs/core/lib/connectors/useEditor.js","webpack:////Users/prevwong/Documents/GitHub/react-page-builder/node_modules/@craftjs/core/lib/editor/actions.js","webpack:////Users/prevwong/Documents/GitHub/react-page-builder/node_modules/@craftjs/core/lib/editor/query.js","webpack:////Users/prevwong/Documents/GitHub/react-page-builder/node_modules/@craftjs/core/lib/utils/createNode.js"],"sourcesContent":["import { useInternalEditor } from \"../editor/useInternalEditor\";\nexport function useEditor(collect) {\n    const { handlers, actions: { setDOM, setNodeEvent, replaceNodes, reset, ...actions }, query: { deserialize, ...query }, ...collected } = collect ? useInternalEditor(collect) : useInternalEditor();\n    return {\n        connectors: handlers,\n        actions,\n        query,\n        ...collected\n    };\n}\n","import { ERROR_INVALID_NODEID, ERROR_ROOT_CANVAS_NO_ID, ROOT_NODE } from \"@craftjs/utils\";\nimport { isCanvas, isTopLevelCanvas } from \"../nodes\";\nimport { updateEventsNode } from \"../utils/updateEventsNode\";\nconst invariant = require('invariant');\nconst Actions = (state, query) => {\n    const _ = (name) => Actions(state, query)[name];\n    return {\n        setOptions(cb) {\n            cb(state.options);\n        },\n        setIndicator(indicator) {\n            if (indicator && (!indicator.placement.parent.dom || (indicator.placement.currentNode && !indicator.placement.currentNode.dom)))\n                return;\n            state.events.indicator = indicator;\n        },\n        setNodeEvent(eventType, id) {\n            const current = state.events[eventType];\n            if (current && id != current) {\n                state.nodes[current].events[eventType] = false;\n            }\n            if (id) {\n                const node = state.nodes[id];\n                state.nodes[id].events[eventType] = true;\n                state.events[eventType] = id;\n            }\n            else {\n                state.events[eventType] = null;\n            }\n        },\n        replaceNodes(nodes) {\n            state.nodes = nodes;\n        },\n        add(nodes, parentId) {\n            if (!Array.isArray(nodes))\n                nodes = [nodes];\n            if (parentId && !state.nodes[parentId].data.nodes && isCanvas(state.nodes[parentId]))\n                state.nodes[parentId].data.nodes = [];\n            nodes.forEach(node => {\n                const parent = parentId ? parentId : node.data.parent, parentNode = state.nodes[parent];\n                if (parentNode && isCanvas(node) && !isCanvas(parentNode)) {\n                    invariant(node.data.props.id, ERROR_ROOT_CANVAS_NO_ID);\n                    if (!parentNode.data._childCanvas)\n                        parentNode.data._childCanvas = {};\n                    node.data.parent = parentNode.id;\n                    parentNode.data._childCanvas[node.data.props.id] = node.id;\n                    delete node.data.props.id;\n                }\n                else {\n                    if (parentId)\n                        query.canDropInParent(node, parentId);\n                    if (parentNode) {\n                        if (parentNode.data.props.children)\n                            delete parentNode.data.props[\"children\"];\n                        // if (parentId && !state.nodes[parentId].data.nodes) state.nodes[parentId].data.nodes = [];\n                        if (!parentNode.data.nodes)\n                            parentNode.data.nodes = [];\n                        const currentNodes = parentNode.data.nodes;\n                        currentNodes.splice((node.data.index !== undefined) ? node.data.index : currentNodes.length, 0, node.id);\n                        node.data.parent = parent;\n                    }\n                }\n                state.nodes[node.id] = node;\n            });\n        },\n        reset() {\n            state.nodes = {};\n            state.events = {\n                dragged: null,\n                selected: null,\n                hovered: null,\n                indicator: null\n            };\n        },\n        move(targetId, newParentId, index) {\n            const targetNode = state.nodes[targetId], newParent = state.nodes[newParentId], newParentNodes = newParent.data.nodes;\n            query.canDropInParent(targetNode, newParentId);\n            const currentParent = state.nodes[targetNode.data.parent], currentParentNodes = currentParent.data.nodes;\n            currentParentNodes[currentParentNodes.indexOf(targetId)] = \"marked\";\n            if (newParentNodes)\n                newParentNodes.splice(index, 0, targetId);\n            else\n                newParent.data.nodes = [targetId];\n            state.nodes[targetId].data.parent = newParentId;\n            state.nodes[targetId].data.index = index;\n            currentParentNodes.splice(currentParentNodes.indexOf(\"marked\"), 1);\n            // updateEventsNode(state, targetId);\n        },\n        delete(id) {\n            invariant(id != ROOT_NODE, \"Cannot delete Root node\");\n            const targetNode = state.nodes[id];\n            if (isCanvas(targetNode)) {\n                invariant(!isTopLevelCanvas(targetNode), \"Cannot delete a Canvas that is not a direct child of another Canvas\");\n                targetNode.data.nodes.map((childId) => {\n                    _(\"delete\")(childId);\n                });\n            }\n            const parentNode = state.nodes[targetNode.data.parent];\n            if (parentNode && parentNode.data.nodes.indexOf(id) > -1) {\n                parentNode.data.nodes.splice(parentNode.data.nodes.indexOf(id), 1);\n            }\n            updateEventsNode(state, id, true);\n            delete state.nodes[id];\n        },\n        setProp(id, cb) {\n            invariant(state.nodes[id], ERROR_INVALID_NODEID);\n            cb(state.nodes[id].data.props);\n            // updateEventsNode(state, id);\n        },\n        setDOM(id, dom) {\n            invariant(state.nodes[id], ERROR_INVALID_NODEID);\n            state.nodes[id].dom = dom;\n            // updateEventsNode(state, id);\n        },\n        setHidden(id, bool) {\n            state.nodes[id].data.hidden = bool;\n        },\n        setCustom(id, cb) {\n            cb(state.nodes[id].data.custom);\n        }\n    };\n};\nexport default Actions;\n","import React from \"react\";\nimport { isCanvas, isRoot } from \"../nodes\";\nimport { serializeNode } from \"../utils/serializeNode\";\nimport { deserializeNode } from \"../utils/deserializeNode\";\nimport { resolveComponent } from \"../utils/resolveComponent\";\nimport invariant from \"invariant\";\nimport { ROOT_NODE, ERRROR_NOT_IN_RESOLVER, ERROR_MOVE_TO_NONCANVAS_PARENT, ERROR_MOVE_OUTGOING_PARENT, ERROR_MOVE_INCOMING_PARENT, ERROR_MOVE_TO_DESCENDANT, ERROR_MOVE_NONCANVAS_CHILD, ERROR_DUPLICATE_NODEID, ERROR_NOPARENT, getDOMInfo, ERROR_CANNOT_DRAG, ERROR_MOVE_ROOT_CANVAS, } from \"@craftjs/utils\";\nimport findPosition from \"../events/findPosition\";\nimport { getDeepNodes } from \"../utils/getDeepNodes\";\nimport { transformJSXToNode } from \"../utils/transformJSX\";\n/**\n * Editor methods used to query nodes\n * @param nodes\n */\nconst getNodeFromIdOrNode = (node, cb) => typeof node === \"string\" ? cb(node) : node;\nexport function QueryMethods(Editor) {\n    const _ = (name) => QueryMethods(Editor)[name];\n    const options = Editor && Editor.options;\n    return {\n        getOptions() {\n            return options;\n        },\n        getNode(id) {\n            return Editor.nodes[id];\n        },\n        createNode(child, extras) {\n            const node = transformJSXToNode(child, extras);\n            const name = resolveComponent(options.resolver, node.data.type);\n            invariant(name != null, ERRROR_NOT_IN_RESOLVER);\n            node.data.displayName = node.data.displayName || name;\n            node.data.name = name;\n            return node;\n        },\n        getDeepNodes(id, deep = true) {\n            return getDeepNodes(Editor.nodes, id, deep);\n        },\n        getAllParents(nodeId, result = []) {\n            const node = Editor.nodes[nodeId];\n            const parent = node.data.parent;\n            if (parent) {\n                result.push(parent);\n                _(\"getAllParents\")(parent, result);\n            }\n            return result;\n        },\n        getAllCanvas(parent = ROOT_NODE) {\n            const bound = _(\"getDeepNodes\")(parent);\n            return (parent === ROOT_NODE ? [ROOT_NODE, ...bound] : bound).filter(id => {\n                if (isCanvas(Editor.nodes[id]))\n                    return true;\n                return false;\n            });\n        },\n        serialize() {\n            const simplifiedNodes = Object.keys(Editor.nodes).reduce((result, id) => {\n                const { data: { ...data }, } = Editor.nodes[id];\n                result[id] = serializeNode({ ...data }, options.resolver);\n                return result;\n            }, {});\n            const json = JSON.stringify(simplifiedNodes);\n            return json;\n        },\n        deserialize(json) {\n            const reducedNodes = JSON.parse(json);\n            return Object.keys(reducedNodes).reduce((accum, id) => {\n                const { type: Comp, props, parent, nodes, _childCanvas, isCanvas, custom, name, } = deserializeNode(reducedNodes[id], options.resolver);\n                if (!Comp)\n                    return accum;\n                accum[id] = _(\"createNode\")(React.createElement(Comp, Object.assign({}, props)), {\n                    id,\n                    data: {\n                        ...(isCanvas && { isCanvas }),\n                        parent,\n                        ...(isCanvas && { nodes }),\n                        ...(_childCanvas && { _childCanvas }),\n                        custom\n                    },\n                });\n                return accum;\n            }, {});\n        },\n        canDragNode: (node) => {\n            const targetNode = getNodeFromIdOrNode(node, (id) => Editor.nodes[id]);\n            if (!isRoot(targetNode)) {\n                invariant(isCanvas(targetNode.data.parent) == true, ERROR_MOVE_ROOT_CANVAS);\n                invariant(targetNode.rules.canDrag(targetNode), ERROR_CANNOT_DRAG);\n            }\n            return true;\n        },\n        canDropInParent: (node, newParent) => {\n            const targetNode = getNodeFromIdOrNode(node, (id) => Editor.nodes[id]);\n            const currentParentNode = targetNode.data.parent &&\n                Editor.nodes[targetNode.data.parent], newParentNode = Editor.nodes[newParent];\n            invariant(currentParentNode ||\n                (!currentParentNode && !Editor.nodes[targetNode.id]), ERROR_DUPLICATE_NODEID);\n            invariant((targetNode.id !== ROOT_NODE && newParent) ||\n                (targetNode.id === ROOT_NODE && !newParent), ERROR_NOPARENT);\n            if (newParent) {\n                invariant(isCanvas(newParentNode), ERROR_MOVE_TO_NONCANVAS_PARENT);\n                invariant(newParentNode.rules.canMoveIn(targetNode, newParentNode), ERROR_MOVE_INCOMING_PARENT);\n            }\n            if (currentParentNode) {\n                // moving\n                const targetDeepNodes = _(\"getDeepNodes\")(targetNode.id);\n                invariant(targetNode.data.parent, ERROR_MOVE_NONCANVAS_CHILD);\n                invariant(!targetDeepNodes.includes(newParent), ERROR_MOVE_TO_DESCENDANT);\n                invariant(currentParentNode.rules.canMoveOut(targetNode, currentParentNode), ERROR_MOVE_OUTGOING_PARENT);\n            }\n            return true;\n        },\n        getDropPlaceholder: (source, target, pos, nodesToDOM = node => Editor.nodes[node.id].dom) => {\n            if (source === target)\n                return;\n            const targetNode = Editor.nodes[target], isTargetCanvas = isCanvas(targetNode);\n            const targetParent = (isTargetCanvas) ? targetNode\n                : Editor.nodes[targetNode.data.parent];\n            const targetParentNodes = targetParent.data._childCanvas\n                ? Object.values(targetParent.data._childCanvas)\n                : targetParent.data.nodes || [];\n            const dimensionsInContainer = targetParentNodes ? targetParentNodes.reduce((result, id) => {\n                const dom = nodesToDOM(Editor.nodes[id]);\n                if (dom) {\n                    result.push({\n                        id,\n                        ...getDOMInfo(dom),\n                    });\n                }\n                return result;\n            }, []) : [];\n            const dropAction = findPosition(targetParent, dimensionsInContainer, pos.x, pos.y);\n            const currentNode = targetParentNodes.length\n                ? Editor.nodes[targetParentNodes[dropAction.index]]\n                : null;\n            const output = {\n                placement: {\n                    ...dropAction,\n                    currentNode,\n                },\n                error: null,\n            };\n            try {\n                _(\"canDragNode\")(source);\n                _(\"canDropInParent\")(source, targetParent.id);\n            }\n            catch (error) {\n                output.error = error;\n            }\n            return output;\n        },\n    };\n}\n","import React from 'react';\nimport { produce } from \"immer\";\nimport { Canvas } from \"../nodes\";\nimport { NodeProvider } from \"../nodes/NodeContext\";\nexport function createNode(data, id) {\n    let actualType = (data.type);\n    const { canMoveIn, canMoveOut, ...props } = data.props;\n    let node = produce({}, (node) => {\n        node.id = id;\n        node.data = {\n            ...data,\n            parent: data.parent || null,\n            name: null,\n            displayName: null,\n            props,\n            custom: data.custom || {}\n        };\n        node.related = {};\n        node.events = {\n            selected: false,\n            dragged: false,\n            hovered: false\n        };\n        node.rules = {\n            canDrag: () => true,\n            canMoveIn: () => true,\n            canMoveOut: () => true,\n            ...((actualType.craft && actualType.craft.rules) || {}),\n        };\n        if (node.data.type === Canvas) {\n            node.data.type = node.data.props.is ? node.data.props.is : 'div';\n            node.data.isCanvas = true;\n            actualType = node.data.type;\n            delete node.data.props[\"is\"];\n        }\n        node.data.props = {\n            ...((actualType.craft && actualType.craft.defaultProps) || {}),\n            ...node.data.props,\n        };\n        if (actualType.craft) {\n            if (actualType.craft.name) {\n                node.data.displayName = actualType.craft.name;\n            }\n            if (actualType.craft.rules) {\n                Object.keys(actualType.craft.rules).forEach(key => {\n                    if (['canDrag', 'canMoveIn', 'canMoveOut'].includes(key)) {\n                        node.rules[key] = actualType.craft.rules[key];\n                    }\n                });\n            }\n            if (actualType.craft.related) {\n                node.related = {};\n                Object.keys(actualType.craft.related).forEach((comp) => {\n                    node.related[comp] = () => React.createElement(NodeProvider, { id, related: true }, React.createElement(actualType.craft.related[comp]));\n                });\n            }\n        }\n    });\n    return node;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAHA;AAMA;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAhFA;AAkFA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAhHA;AAkHA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAIA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAFA;AAGA;AAAA;AACA;AAAA;AACA;AALA;AAFA;AAUA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AAEA;AAGA;AACA;AACA;AAAA;AACA;AACA;AADA;AAIA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAFA;AAIA;AALA;AACA;AAMA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAlIA;AAoIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}