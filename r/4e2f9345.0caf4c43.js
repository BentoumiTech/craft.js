(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{156:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"metadata",(function(){return s})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return p}));var o=t(47),a=t(207),r=(t(0),t(208)),i=t(210),l={id:"basic-tutorial",title:"Basic Tutorial"},s={id:"guides/basic-tutorial",title:"Basic Tutorial",description:"Live Demo",source:"@site/docs/guides/basic-tutorial.md",permalink:"/r/docs/next/guides/basic-tutorial",version:"next",sidebar:"docs",previous:{title:"Interacting with the Editor",permalink:"/r/docs/next/concepts/editor-components"},next:{title:"Save and Load",permalink:"/r/docs/next/guides/save-load-state"}},c=[{value:"Overview",id:"overview",children:[]},{value:"Installation",id:"installation",children:[]},{value:"Designing a user interface",id:"designing-a-user-interface",children:[{value:"User Components",id:"user-components",children:[]},{value:"The Editor",id:"the-editor",children:[]}]},{value:"Implementing Craft.js",id:"implementing-craftjs",children:[{value:"Setup",id:"setup",children:[]},{value:"Enabling Drag and Drop",id:"enabling-drag-and-drop",children:[]},{value:"Implementing the Toolbox",id:"implementing-the-toolbox",children:[]},{value:"Making the components editable",id:"making-the-components-editable",children:[]},{value:"Settings Panel",id:"settings-panel-1",children:[]},{value:"Topbar",id:"topbar",children:[]}]},{value:"You made it \ud83c\udf89",id:"you-made-it-",children:[]}],d={rightToc:c};function p(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},d,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("a",{target:"_blank",href:"https://prevwong.github.io/craft.js/examples/basic",className:"btn"},"Live Demo"),Object(r.b)("a",{target:"_blank",href:"https://github.com/prevwong/craft.js/tree/master/packages/examples/basic",className:"btn btn-text"},"View Code"),Object(r.b)("h2",{id:"overview"},"Overview"),Object(r.b)("p",null,"In this tutorial, we'll be designing a simple page editor. It's recommended that you have a basic to intermediate workings of React and it'd be even better if you first have a quick glance at the ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"/r/docs/next/concepts/nodes"}),"Core Concepts")," and come back here. If you are feeling adventurous, that's fine too."),Object(r.b)("h2",{id:"installation"},"Installation"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-bash"}),"yarn add @craftjs/core\n")),Object(r.b)("p",null,"or with npm:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-bash"}),"npm install --save @craftjs/core\n")),Object(r.b)("h2",{id:"designing-a-user-interface"},"Designing a user interface"),Object(r.b)("p",null,"With Craft.js you decide how your editor should look and function. So, let's build a user interface for our page editor. We'll add the page editor functionalities later."),Object(r.b)("p",null,"To make our lives easier, we'll use some external packages for designing our user interfaces."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-bash"}),"yarn add @material-ui/core react-contenteditable material-ui-color-picker\n")),Object(r.b)("h3",{id:"user-components"},"User Components"),Object(r.b)("p",null,"Let's first create the User Components - the components that our end users will be able create/edit/move around. "),Object(r.b)("h4",{id:"text"},"Text"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/user/Text.js\nimport React from "react";\n\nexport const Text = ({text, fontSize}) => {\n  return (\n      <div>\n         <p style={{fontSize}}>{text}</p>\n      </div>\n  )\n}\n')),Object(r.b)("h4",{id:"button"},"Button"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/user/Button.js\nimport React  from "react";\nimport {Button as MaterialButton} from "@material-ui/core";\n\nexport const Button = ({size, variant, color, children}) => {\n  return (\n    <MaterialButton size={size} variant={variant} color={color}>\n      {children}\n    </MaterialButton>\n  )\n}\n')),Object(r.b)("h4",{id:"container"},"Container"),Object(r.b)("p",null,"We will also create a Container component to allow our users to change its background colour and padding."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/user/Container.js\nimport React from "react";\nimport { Paper } from "@material-ui/core";\n\nexport const Container = ({background, padding = 0, children}) => {\n  return (\n    <Paper style={{margin: "5px 0", background, padding: `${padding}px`}}>\n      {children}\n    </Paper>\n  )\n}\n')),Object(r.b)("h4",{id:"card"},"Card"),Object(r.b)("p",null,"Now, let's create another user component that will be more advanced. It will be composed of the Container component we made earlier, and it will contain two droppable regions; one for text and another for buttons."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/user/Card.js\nimport React  from "react";\nimport { Text } from "./Text";\nimport { Button } from "./Button";\nimport { Container } from "./Container";\n\nexport const Card = ({background, padding = 20}) => {\n  return (\n    <Container background={background} padding={padding}>\n      <div className="text-only">\n        <Text text="Title" fontSize={20} />\n        <Text text="Subtitle" fontSize={15} />\n      </div>\n      <div className="buttons-only">\n        <Button size="small" text="Learn more" variant="contained" color="primary" />\n      </div>\n    </Container>\n  )\n}\n\n')),Object(r.b)("h3",{id:"the-editor"},"The Editor"),Object(r.b)("h4",{id:"toolbox"},"Toolbox"),Object(r.b)("p",null,'Let\'s build a "toolbox" which our users will be able to drag and drop to create new instances of those User Components we just defined.'),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/Toolbox.js\nimport React from "react";\nimport { Box, Typography, Grid, Button as MaterialButton } from "@material-ui/core";\n\nexport const Toolbox = () => {\n  return (\n    <Box px={2} py={2}>\n      <Grid container direction="column"  alignItems="center" justify="center" spacing={1}>\n        <Box pb={2}>\n          <Typography>Drag to add</Typography>\n        </Box>\n        <Grid container direction="column" item>\n          <MaterialButton variant="contained">Button</MaterialButton>\n        </Grid>\n        <Grid container direction="column" item>\n          <MaterialButton variant="contained">Text</MaterialButton>\n        </Grid>\n        <Grid container direction="column" item>\n          <MaterialButton variant="contained">Container</MaterialButton>\n        </Grid>\n        <Grid container direction="column" item>\n          <MaterialButton variant="contained">Card</MaterialButton>\n        </Grid>\n      </Grid>\n    </Box>\n  )\n};\n')),Object(r.b)("h4",{id:"settings-panel"},"Settings Panel"),Object(r.b)("p",null,"We also want to create a section here where we can display a bunch of settings which our users can use to edit the props of the user components."),Object(r.b)("p",null,"For now, let's just put in some dummy text fields. We'll revisit this in the later sections."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/SettingsPanel.js\nimport React from \'react\';\nimport { Box, Chip, Grid, Typography, Button as MaterialButton, FormControl, FormLabel, Slider } from "@material-ui/core";\n\nexport const SettingsPanel = () => {  \n  return  (    \n    <Box bgcolor="rgba(0, 0, 0, 0.06)" mt={2} px={2} py={2}>\n      <Grid container direction="column" spacing={0}>\n        <Grid item>\n          <Box pb={2}>\n            <Grid container alignItems="center">\n              <Grid item xs><Typography variant="subtitle1">Selected</Typography></Grid>\n              <Grid item><Chip size="small" color="primary" label="Selected" /></Grid>\n            </Grid>\n          </Box>\n        </Grid>\n        <FormControl size="small" component="fieldset">\n          <FormLabel component="legend">Prop</FormLabel>\n          <Slider\n            defaultValue={0}\n            step={1}\n            min={7}\n            max={50}\n            valueLabelDisplay="auto"\n          />\n        </FormControl>\n        <MaterialButton\n          variant="contained"\n          color="default"\n        >\n          Delete\n        </MaterialButton>\n      </Grid>\n    </Box>\n  ) \n}\n')),Object(r.b)("h4",{id:"top-bar"},"Top bar"),Object(r.b)("p",null,"Let's design a section that is going to contain a switch for users to disable the editor's functionality and also a button that is simply going to display the serialized output in the browser's console."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/Topbar.js\nimport React from "react";\nimport { Box, FormControlLabel, Switch, Grid, Button as MaterialButton } from "@material-ui/core";\n\nexport const Topbar = () => {\n  return (\n    <Box px={1} py={1} mt={3} mb={1} bgcolor="#cbe8e7">\n      <Grid container alignItems="center">\n        <Grid item xs>\n          <FormControlLabel\n            control={<Switch checked={true} />}\n            label="Enable"\n          />\n        </Grid>\n        <Grid item>\n          <MaterialButton size="small" variant="outlined" color="secondary">Serialize JSON to console</MaterialButton>\n        </Grid>\n      </Grid>\n    </Box>\n  )\n};\n')),Object(r.b)("h4",{id:"putting-it-all-together"},"Putting it all together"),Object(r.b)("p",null,"Now, let's put together our entire React application. "),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"// pages/index.js\n\nimport React from 'react';\nimport {Typography, Paper, Grid} from '@material-ui/core';\n\nimport { Toolbox } from '../components/Toolbox';\nimport { SettingsPanel } from '../components/SettingsPanel';\nimport { Topbar } from '../components/Topbar';\n\nimport { Container } from '../components/user/Container';\nimport { Button } from '../components/user/Button';\nimport { Card } from '../components/user/Card';\nimport { Text } from '../components/user/Text';\n\nexport default function App() {\n  return (\n    <div style={{margin: \"0 auto\", width: \"800px\"}}>\n      <Typography variant=\"h5\" align=\"center\">A super simple page editor</Typography>\n      <Grid container spacing={3} style={{paddingTop: \"10px\"}}>\n        <Topbar />\n        <Grid item xs>\n          <Container padding={5} background=\"#eee\">\n            <Card />\n          </Container>\n        </Grid>\n        <Grid item xs={3}>\n          <Paper>\n              <Toolbox />\n              <SettingsPanel />\n          </Paper>          \n        </Grid>\n      </Grid>\n    </div>\n  );\n}\n\n")),Object(r.b)(i.c,{img:"tutorial/interface.png",mdxType:"Image"}),Object(r.b)("h2",{id:"implementing-craftjs"},"Implementing Craft.js"),Object(r.b)("p",null,"Up to this point, we have made a user interface for our page editor. Now, let's get it to work!"),Object(r.b)("h3",{id:"setup"},"Setup"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"First wrap our application with ",Object(r.b)("inlineCode",{parentName:"li"},"<Editor />")," which sets up the Editor's context. We'll also need to specify the list of user components in the ",Object(r.b)("inlineCode",{parentName:"li"},"resolver")," prop for Craft.js to be able to (de)serialize our User Components."),Object(r.b)("li",{parentName:"ul"},"Then wrap the editable area with ",Object(r.b)("inlineCode",{parentName:"li"},"<Frame />")," which passes the rendering process to Craft.js.")),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{19,22,31,40}","{19,22,31,40}":!0}),'// pages/index.js\nimport React from \'react\';\nimport {Typography, Paper, Grid} from \'@material-ui/core\';\n\nimport { Toolbox } from \'../components/Toolbox\';\nimport { SettingsPanel } from \'../components/SettingsPanel\';\n\nimport { Container } from \'../components/user/Container\';\nimport { Button } from \'../components/user/Button\';\nimport { Card } from \'../components/user/Card\';\nimport { Text } from \'../components/user/Text\';\n\nimport {Editor, Frame, Element} from "@craftjs/core";\n\nexport default function App() {\n  return (\n    <div>\n      <Typography variant="h5" align="center">A super simple page editor</Typography>\n        <Editor resolver={{Card, Button, Text, Container}}> \n          <Grid container spacing={3}>\n            <Grid item xs>\n              <Frame>\n                <Container padding={5} background="#eee">\n                  <Card />\n                  <Button size="small" variant="outlined">Click</Button>\n                  <Text size="small" text="Hi world!" />\n                  <Container padding={6} background="#999">\n                    <Text size="small" text="It\'s me again!" />\n                  </Container>\n                </Container>\n              </Frame>\n            </Grid>\n            <Grid item xs={3}>\n              <Paper className={classes.root}>\n                  <Toolbox />\n                  <SettingsPanel />\n              </Paper>          \n            </Grid>\n          </Grid>\n        </Editor>\n    </div>\n  );\n}\n')),Object(r.b)("p",null,"Every element that is rendered in ",Object(r.b)("inlineCode",{parentName:"p"},"<Frame />")," is managed by an object in the editor's internal state called a ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," which describes the element, its events, and props among other things."),Object(r.b)("p",null,"Whether an element is draggable or droppable (or neither) depends on the type of ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," that manages it. "),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"If the ",Object(r.b)("inlineCode",{parentName:"li"},"Node")," is a Canvas, then it's droppable"),Object(r.b)("li",{parentName:"ul"},"If the ",Object(r.b)("inlineCode",{parentName:"li"},"Node")," is an immediate child of a Canvas, then it's draggable.")),Object(r.b)("p",null,"By default, every element inside the ",Object(r.b)("inlineCode",{parentName:"p"},"<Frame />")," will have a non-Canvas Node automatically defined for it:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// Explanation\n<Frame>\n  <Container padding={5} background="#eee"> // Node of type Container\n    <Card /> // Node of type Card\n    <Button size="small" variant="outlined">Click</Button> // Node of type Button\n    <Text size="small" text="Hi world!" /> // Node of type Text\n    <Container padding={2} background="#999"> // Node of type Container\n       <Text size="small" text="It\'s me again!" /> // Node of type Text\n    </Container>\n  </Container>\n</Frame>\n')),Object(r.b)("p",null,"Hence, by default, all the Nodes above are neither draggable nor droppable. So how can we define some of the Nodes above as a Canvas Node? "),Object(r.b)("p",null,"We can use the provided ",Object(r.b)("inlineCode",{parentName:"p"},"<Element />")," component to manually define Nodes:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{2,6}","{2,6}":!0}),'<Frame>\n  <Element is={Container} padding={5} background="#eee" canvas> // Canvas Node of type Container, droppable\n    <Card /> // Node of type Card\n    <Button size="small" variant="outlined">Click</Button> // Node of type Button, draggable\n    <Text size="small" text="Hi world!" /> // Node of type Text, draggable\n    <Element is={Container} padding={2} background="#999" canvas> // Canvas Node of type Container, droppable and draggable\n       <Text size="small" text="It\'s me again!" /> // Node of type Text, draggable\n    </Element>\n  </Element>\n</Frame>\n')),Object(r.b)("p",null,"In the above code, we've wrapped our ",Object(r.b)("inlineCode",{parentName:"p"},"Container")," components with ",Object(r.b)("inlineCode",{parentName:"p"},"<Element />")," with the ",Object(r.b)("inlineCode",{parentName:"p"},"canvas")," prop, thus making the component droppable and its immediate children, draggable."),Object(r.b)("p",null,"Once you've applied these changes and refresh the page, you will notice that absolutely nothing has changed - and that's a good thing!"),Object(r.b)("h3",{id:"enabling-drag-and-drop"},"Enabling Drag and Drop"),Object(r.b)("p",null,"Inside a User Component, we have access to the ",Object(r.b)("inlineCode",{parentName:"p"},"useNode")," hook which provides several information and methods related to the corresponding ",Object(r.b)("inlineCode",{parentName:"p"},"Node"),". "),Object(r.b)("p",null,"The first thing we will need to do is to let Craft.js to manage the DOM of our component. The hook provides ",Object(r.b)("inlineCode",{parentName:"p"},"connectors")," which act as a bridge between the DOM and the events in Craft.js:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{4,7,10}","{4,7,10}":!0}),'// components/user/Text.js\nimport React from "react";\nimport { Typography } from "@material-ui/core";\nimport { useNode } from "@craftjs/core";\n\nexport const Text = ({text}) => {\n  const { connectors: {connect, drag} } = useNode();\n  return (\n     <div \n      ref={ref => connect(drag(ref))}\n    >\n      <p>{text}</p>\n    </div>\n  )\n}\n')),Object(r.b)("p",null,"Let's break this down a little:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"We passed the ",Object(r.b)("inlineCode",{parentName:"li"},"connect")," connector to the root element of our component; this tells Craft.js that this element represents the Text component. If the component's corresponding Node is a Canvas, then this also defines the area that is droppable."),Object(r.b)("li",{parentName:"ul"},"Then, we also passed ",Object(r.b)("inlineCode",{parentName:"li"},"drag")," connector to the same root element; this adds the drag handlers to the DOM. If the component's Node is a child of a Canvas, then the user will be able to drag this element and it will move the entire Text component.")),Object(r.b)("p",null,"We can also specify additional configuration to our component via the ",Object(r.b)("inlineCode",{parentName:"p"},"craft")," prop. Let's define drag-n-drop rules for our Text Component:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'export const Text = () => {...}\nText.craft = {\n  ...\n  rules: {\n    canDrag: (node) => node.data.props.text != "Drag"\n  }\n}\n')),Object(r.b)("p",null,"Our Text component can now only be dragged if the ",Object(r.b)("inlineCode",{parentName:"p"},"text"),' prop is not set to "Drag" \ud83e\udd2a'),Object(r.b)("p",null,"Nice, now let's enable drag-n-drop for the other User Components:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{3,5}","{3,5}":!0}),"// components/user/Button.js\nexport const Button = ({size, variant, color, children}) => {\n  const { connectors: {connect, drag} } = useNode();\n  return (\n    <MaterialButton ref={ ref => connect(drag(ref))} size={size} variant={variant} color={color} >\n      ...\n    </MaterialButton>\n  )\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{3,5}","{3,5}":!0}),"// components/user/Container.js\nexport const Container = ({background, padding = 0, children}) => {\n  const { connectors: {connect, drag} } = useNode();\n  return (\n    <Paper ref={ref=> connect(drag(ref))} style={{ background, padding: `${padding}px`}}>\n      ...\n    </Paper>\n  )\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"// components/user/Card.js (No changes)\n\n// It's not necessary to add connectors for our Card component since it's a composition of our Container component - which already has connectors applied.\nexport const Card = ({background, padding = 0}) => {\n  return (\n    <Container background={background} padding={padding}>\n      ...\n    </Container>\n  )\n}\n")),Object(r.b)("p",null,"At this point, you could refresh the page and you would be able to drag stuff around."),Object(r.b)(i.c,{img:"tutorial/dnd.gif",mdxType:"Image"}),Object(r.b)("h4",{id:"defining-droppable-regions"},"Defining Droppable regions"),Object(r.b)("p",null,"Of course, our Card component is supposed to have 2 droppable regions, which means we'll need 2 Canvas nodes. "),Object(r.b)("p",null,"But hold up, how do we even create a Node inside a User Component?  Remember the ",Object(r.b)("inlineCode",{parentName:"p"},"<Element />")," component that was used to define Nodes earlier in our application? Well it can be used here as well."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{2,7,10,11,13}","{2,7,10,11,13}":!0}),'// components/user/Card.js\nimport {useNode, Element} from "@craftjs/core";\n\nexport const Card = (({bg, padding})) => {\n  return (\n    <Container background={background} padding={padding}>\n      <Element id="text" canvas> // Canvas Node of type div\n        <Text text="Title" fontSize={20} />\n        <Text text="Subtitle" fontSize={15} />\n      </Element>\n      <Element id="buttons" canvas> // Canvas Node of type div\n        <Button size="small" text="Learn more" />\n      </Element>\n    </Container>\n  )\n}\n')),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},Object(r.b)("inlineCode",{parentName:"p"},"<Element />")," used inside User Component must specify an ",Object(r.b)("inlineCode",{parentName:"p"},"id")," prop")),Object(r.b)("p",null,"You might be wondering how do we set drag/drop rules for the new droppable regions we made. Currently, we have set the ",Object(r.b)("inlineCode",{parentName:"p"},"is")," prop in our ",Object(r.b)("inlineCode",{parentName:"p"},"<Element />")," to a div, but we can actually point it to a User Component. "),Object(r.b)("p",null,"Hence, we can specify and create a new User Component and define rules via the ",Object(r.b)("inlineCode",{parentName:"p"},"craft")," prop just like what we have done previously."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/user/Card.js\nimport React  from "react";\nimport Text from "./Text";\nimport Button from "./Button";\nimport { Element, useNode } from "@craftjs/core";\n\nimport { Container }  from "./Container";\n\n// Notice how CardTop and CardBottom do not specify the drag connector. This is because we won\'t be using these components as draggables; adding the drag handler would be pointless.\n\nexport const CardTop = ({children}) => {\n  const { connectors: {connect} } = useNode();\n  return (\n    <div ref={connect} className="text-only">\n      {children}\n    </div>\n  )\n}\n\nCardTop.craft = {\n  rules: {\n    // Only accept Text\n    canMoveIn: (incomingNode) => incomingNode.data.type == Text\n  }\n}\n\nexport const CardBottom = ({children}) => {\n  const { connectors: {connect} } = useNode();\n  return (\n    <div ref={connect}>\n      {children}\n    </div>\n  )\n}\n\nCardBottom.craft = {\n  rules: {\n    // Only accept Buttons\n    canMoveIn : (incomingNode) => incomingNode.data.type == Button\n  }\n}\n\nexport const Card = ({background, padding = 20}) => {\n  return (\n    <Container background={background} padding={padding}>\n      <Element id="text" is={CardTop} canvas> // Canvas Node of type CardTop\n        <Text text="Title" fontSize={20} />\n        <Text text="Subtitle" fontSize={15} />\n      </Element>\n      <Element id="buttons" is={CardBottom} canvas> // Canvas Node of type CardBottom\n        <Button size="small" text="Learn more" />\n      </Element>\n    </Container>\n  )\n}\n')),Object(r.b)("p",null,"Remember that every User Component must be added to our resolver, so let's add CardTop and CardBottom:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"...\nexport default function App() {\n  return (\n    ...\n        <Editor\n          resolver={{Card, Button, Text, CardTop, CardBottom}}\n        > \n         ...\n        </Editor>\n     ...\n  );\n}\n")),Object(r.b)(i.c,{img:"tutorial/droppable-regions.gif",mdxType:"Image"}),Object(r.b)("h3",{id:"implementing-the-toolbox"},"Implementing the Toolbox"),Object(r.b)("p",null,"Let's go back to our Toolbox component and modify it so that dragging those buttons into the editor will create new instances of the user components they represent. Just as ",Object(r.b)("inlineCode",{parentName:"p"},"useNode")," provides methods and information related to a specific ",Object(r.b)("inlineCode",{parentName:"p"},"Node"),", ",Object(r.b)("inlineCode",{parentName:"p"},"useEditor")," specifies methods and information related to the entire editor's state."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"useEditor")," also provides ",Object(r.b)("inlineCode",{parentName:"p"},"connectors"),"; the one we are interested in right now is ",Object(r.b)("inlineCode",{parentName:"p"},"create")," which attaches a drag handler to the  DOM specified in its first argument and creates the element specified in its second argument."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{20,23,26}","{20,23,26}":!0}),'// components/Toolbox.js\nimport React from "react";\nimport { Box, Typography, Grid, Button as MaterialButton } from "@material-ui/core";\nimport { Element, useEditor } from "@craftjs/core";\nimport { Container } from "./user/Container";\nimport { Card } from "./user/Card";\nimport { Button } from "./user/Button";\nimport { Text } from "./user/Text";\n\nexport const Toolbox = () => {\n  const { connectors, query } = useEditor();\n\n  return (\n    <Box px={2} py={2}>\n      <Grid container direction="column"  alignItems="center" justify="center" spacing={1}>\n        <Box pb={2}>\n          <Typography>Drag to add</Typography>\n        </Box>\n        <Grid container direction="column" item>\n          <MaterialButton ref={ref=> connectors.create(ref, <Button text="Click me" size="small" />)} variant="contained">Button</MaterialButton>\n        </Grid>\n        <Grid container direction="column" item>\n          <MaterialButton ref={ref=> connectors.create(ref, <Text text="Hi world" />)} variant="contained">Text</MaterialButton>\n        </Grid>\n        <Grid container direction="column" item>\n          <MaterialButton ref={ref=> connectors.create(ref, <Element is={Container} padding={20} canvas />)} variant="contained">Container</MaterialButton>\n        </Grid>\n        <Grid container direction="column" item>\n          <MaterialButton ref={ref=> connectors.create(ref, <Card />)} variant="contained">Card</MaterialButton>\n        </Grid>\n      </Grid>\n    </Box>\n  )\n};\n')),Object(r.b)("p",null,"Notice for our Container component, we wrapped it with the ",Object(r.b)("inlineCode",{parentName:"p"},"<Element canvas />")," - this will allow our users to drag and drop a new Container component that is droppable."),Object(r.b)("p",null,"Now, you can drag and drop the Buttons, and they will actually create new instances of our User Components."),Object(r.b)("h3",{id:"making-the-components-editable"},"Making the components editable"),Object(r.b)("p",null,"Up until this point, we have a page editor where our users can move elements around. But, we are missing one important thing - enabling our users to edit the components' props."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"useNode")," hook provides us with the method ",Object(r.b)("inlineCode",{parentName:"p"},"setProp")," which can be used to manipulate a component's props. Let's implement a content editable for our Text Component:"),Object(r.b)("p",null,"For simplicity's sake, we will be using ",Object(r.b)("inlineCode",{parentName:"p"},"react-contenteditable")),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{11-20}","{11-20}":!0}),'import React, {useCallback} from "react";\nimport ContentEditable from \'react-contenteditable\'\n\nexport const Text = ({text, fontSize}) => {\n  const { connectors: {connect, drag}, actions: {setProp} } = useNode();\n\n  return (\n     <div \n      ref={ref => connect(drag(ref))}\n    >\n      <ContentEditable\n        html={text} \n        onChange={e => \n          setProp(props => \n            props.text = e.target.value.replace(/<\\/?[^>]+(>|$)/g, "")  \n          )\n        } \n        tagName="p"\n        style={{fontSize: `${fontSize}px`, textAlign}}\n      />\n    </div>\n  )\n}\n')),Object(r.b)("p",null,"But let's only enable content editable only when the component is clicked when it's already selected; a double click is essential. "),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"useNode")," hook accepts a collector function which can be used to retrieve state information related to the corresponding ",Object(r.b)("inlineCode",{parentName:"p"},"Node"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{4-5,8,10,18}","{4-5,8,10,18}":!0}),"// components/user/Text.js\nexport const Text = ({text, fontSize}) => {\n  const { connectors: {connect, drag}, selected, dragged, actions: {setProp} } = useNode((state) => ({\n    selected: state.events.selected,\n    dragged: state.events.dragged\n  }));\n\n  const [editable, setEditable] = useState(false);\n\n  useEffect(() => {!selected && setEditable(false)}, [selected]);\n\n  return (\n     <div \n      ref={ref => connect(drag(ref))}\n      onClick={e => setEditable(true)}\n    >\n      <ContentEditable\n        disabled={!editable}\n       ...\n      />\n    </div>\n  )\n}\n")),Object(r.b)(i.c,{img:"tutorial/text-edit.gif",mdxType:"Image"}),Object(r.b)("p",null,"This should give you an idea of the possibilities of implementing powerful visual editing features like what you'd see in most modern page editors."),Object(r.b)("p",null,"While we are at it, let's also add a slider for users to edit the ",Object(r.b)("inlineCode",{parentName:"p"},"fontSize")),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/user/Text.js\nimport {Slider, FormControl, FormLabel} from "@material-ui/core";\n\nexport const Text= ({text, fontSize, textAlign}) => {\n  const { connectors: {connect, drag}, selected, dragged, actions: {setProp} } = useNode((state) => ({\n    selected: state.events.selected,\n    dragged: state.events.dragged\n  }));\n\n  ...\n\n  return (\n    <div {...}>\n      <ContentEditable {...} />\n      {\n        selected && (\n          <FormControl className="text-additional-settings" size="small">\n            <FormLabel component="legend">Font size</FormLabel>\n            <Slider\n              defaultValue={fontSize}\n              step={1}\n              min={7}\n              max={50}\n              valueLabelDisplay="auto"\n              onChange={(_, value) => {\n                setProp(props => props.fontSize = value);\n              }}\n            />\n          </FormControl>\n        )\n      }\n    </div>\n  )\n}\n')),Object(r.b)(i.c,{img:"tutorial/text-edit-others.gif",mdxType:"Image"}),Object(r.b)("p",null,"We can agree that it does not look all that good since it obstructs the user experience. Wouldn't it be better if the entire ",Object(r.b)("inlineCode",{parentName:"p"},".text-additional-settings")," Grid is relocated to the Settings Panel that we created earlier?"),Object(r.b)("p",null,"The question is, how will the Settings Panel be able render the ",Object(r.b)("inlineCode",{parentName:"p"},".text-additional-settings"),"  when our Text component is selected? "),Object(r.b)("p",null,"This is where Related Components become useful. Essentially, a Related Component shares the same ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," context as our actual User component; it can make use of the ",Object(r.b)("inlineCode",{parentName:"p"},"useNode")," hook. Additionally, a Related Component is registered to a component's ",Object(r.b)("inlineCode",{parentName:"p"},"Node"),", which means we can access and render this component anywhere within the editor. "),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/user/Text.js\nexport const Text = ({text, fontSize}) => {\n  const { connectors: {connect, drag}, isActive, actions: {setProp} } = useNode((node) => ({\n    isActive: node.events.selected\n  }));\n\n  ...\n  return (\n    <div {...}>\n      <ContentEditable {...} />\n    </div>\n  )\n}\n\nconst TextSettings = () => {\n  const { actions: {setProp}, fontSize } = useNode((node) => ({\n    fontSize: node.data.props.fontSize\n  }));\n\n  return (\n    <>\n      <FormControl size="small" component="fieldset">\n        <FormLabel component="legend">Font size</FormLabel>\n        <Slider\n          value={fontSize || 7}\n          step={7}\n          min={1}\n          max={50}\n          onChange={(_, value) => {\n            setProp(props => props.fontSize = value);\n          }}\n        />\n      </FormControl>\n    </>\n  )\n}\n\nText.craft = {\n  ...\n  related: {\n    settings: TextSettings\n  }  \n}\n')),Object(r.b)("p",null,"Before we move on to the Settings Panel, let's quickly do the same for the other User Components:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/user/Button.js\nimport {Button as MaterialButton, Grid, FormControl, FormLabel, RadioGroup,Radio, FormControlLabel} from "@material-ui/core";\nexport const Button = () => {}\n\n\nconst ButtonSettings = () => {\n  const { actions: {setProp}, props } = useNode((node) => ({\n    props: node.data.props\n  }));\n\n  return (\n    <div>\n      <FormControl size="small" component="fieldset">\n        <FormLabel component="legend">Size</FormLabel>\n        <RadioGroup defaultValue={props.size} onChange={(e) => setProp(props => props.size = e.target.value )}>\n          <FormControlLabel label="Small" value="small" control={<Radio size="small" color="primary" />} />\n          <FormControlLabel label="Medium" value="medium" control={<Radio size="small" color="primary" />} />\n          <FormControlLabel label="Large" value="large" control={<Radio size="small" color="primary" />} />\n        </RadioGroup>\n      </FormControl>\n      <FormControl component="fieldset">\n        <FormLabel component="legend">Variant</FormLabel>\n        <RadioGroup defaultValue={props.variant} onChange={(e) => setProp(props => props.variant = e.target.value )}>\n          <FormControlLabel label="Text" value="text" control={<Radio size="small" color="primary" />} />\n          <FormControlLabel label="Outlined" value="outlined" control={<Radio size="small" color="primary" />} />\n          <FormControlLabel label="Contained" value="contained" control={<Radio size="small" color="primary" />} />\n        </RadioGroup>\n      </FormControl>\n      <FormControl component="fieldset">\n        <FormLabel component="legend">Color</FormLabel>\n        <RadioGroup defaultValue={props.color} onChange={(e) => setProp(props => props.color = e.target.value )}>\n          <FormControlLabel label="Default" value="default" control={<Radio size="small" color="default" />} />\n          <FormControlLabel label="Primary" value="primary" control={<Radio size="small" color="primary" />} />\n          <FormControlLabel label="Seconday" value="secondary" control={<Radio size="small" color="primary" />} />\n        </RadioGroup>\n      </FormControl>\n    </div>\n  )\n};\n\nButton.craft = {\n  related: { \n    settings: ButtonSettings\n  }\n}\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/user/Container.js\nimport {FormControl, FormLabel, Slider} from "@material-ui/core";\nimport ColorPicker from \'material-ui-color-picker\'\n\nexport const Container = () => {...}\n\nexport const ContainerSettings = () => {\n  const { background, padding, actions: {setProp} } = useNode(node => ({\n    background: node.data.props.background,\n    padding: node.data.props.padding\n  }));\n  return (\n    <div>\n      <FormControl fullWidth={true} margin="normal" component="fieldset">\n        <FormLabel component="legend">Background</FormLabel>\n        <ColorPicker defaultValue={background || \'#000\'} onChange={color => {\n          setProp(props => props.background = color)\n        }} />\n      </FormControl>\n      <FormControl fullWidth={true} margin="normal" component="fieldset">\n        <FormLabel component="legend">Padding</FormLabel>\n        <Slider defaultValue={padding} onChange={(_, value) => setProp(props => props.padding = value)} />\n      </FormControl>\n    </div>\n  )\n}\n\nContainer.craft = {\n  related: {\n    settings: ContainerSettings\n  }\n}\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/user/Card.js\nimport {ContainerSettings} from "./Container";\n\nexport const Card({background, padding = 20}) { ... }\n\nCard.craft = {\n  related: {\n    // Since Card has the same settings as Container, we\'ll just reuse ContainerSettings \n    settings: ContainerSettings\n  }\n}\n')),Object(r.b)("h4",{id:"setting-default-props"},"Setting default props"),Object(r.b)("p",null,"Setting default props is not strictly necessary. However, it is helpful if we wish to access the component's props via its corresponding ",Object(r.b)("inlineCode",{parentName:"p"},"Node"),", like what we did in the ",Object(r.b)("inlineCode",{parentName:"p"},"settings")," related component above."),Object(r.b)("p",null,"For instance, if a Text component is rendered as ",Object(r.b)("inlineCode",{parentName:"p"},'<Text text="Hi" />'),", we would get a null value when we try to retrieve the ",Object(r.b)("inlineCode",{parentName:"p"},"fontSize")," prop via its ",Object(r.b)("inlineCode",{parentName:"p"},"Node"),". An easy way to solve this is to explicity define each User Component's ",Object(r.b)("inlineCode",{parentName:"p"},"props"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/user/Text.js\nexport const Text = ({text, fontSize}) => {}\n\nText.craft = {\n  props: {\n    text: "Hi",\n    fontSize: 20\n  },\n  rules: {...},\n  related: {...}\n}\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/user/Button.js\nexport const Button = ({size, variant, color, text}) => {}\n\nButton.craft = {\n  props: { \n    size: "small", \n    variant: "contained",\n    color: "primary",\n    text: "Click me"\n  },\n  related: {...}\n}\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/user/Container.js\nexport const Container = ({background, padding}) => {}\n\n// We export this because we\'ll be using this in the Card component as well\nexport const ContainerDefaultProps = {\n  background : "#ffffff",\n  padding: 3\n};\n\nContainer.craft = {\n  props: ContainerDefaultProps,\n  related: {...}\n}\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'// components/user/Card.js\nimport {ContainerDefaultProps} from "./Container";\n\nexport const Card = ({background, padding}) => {}\n\nCard.craft = {\n  props: ContainerDefaultProps,\n  related: {...}\n}\n')),Object(r.b)("h3",{id:"settings-panel-1"},"Settings Panel"),Object(r.b)("p",null,"We need to get the currently selected component which can be obtained from the editor's internal state. Similar to ",Object(r.b)("inlineCode",{parentName:"p"},"useNode"),", a collector function can be specified to ",Object(r.b)("inlineCode",{parentName:"p"},"useEditor"),". The difference is here, we'll be dealing with the editor's internal state rather than with a specific ",Object(r.b)("inlineCode",{parentName:"p"},"Node"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const { currentlySelectedId } = useEditor((state) => ({\n  currentlySelectedId: state.events.selected\n}))\n")),Object(r.b)("p",null,"Now, let's replace the placeholder text fields in our Settings Panel with the ",Object(r.b)("inlineCode",{parentName:"p"},"settings")," Related Component:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{4,7-22,24,35-37}","{4,7-22,24,35-37}":!0}),'// components/SettingsPanel.js\n\nimport { Box, Chip, Grid, Typography, Button as MaterialButton } from "@material-ui/core";\nimport { useEditor } from "@craftjs/core";\n\nexport const SettingsPanel = () => {\n  const { selected } = useEditor((state) => {\n    const currentNodeId = state.events.selected;\n    let selected;\n\n    if ( currentNodeId ) {\n      selected = {\n        id: currentNodeId,\n        name: state.nodes[currentNodeId].data.name,\n        settings: state.nodes[currentNodeId].related && state.nodes[currentNodeId].related.settings\n      };\n    }\n\n    return {\n      selected\n    }\n  });\n\n  return selected ? (    \n    <Box bgcolor="rgba(0, 0, 0, 0.06)" mt={2} px={2} py={2}>\n      <Grid container direction="column" spacing={0}>\n        <Grid item>\n          <Box pb={2}>\n            <Grid container alignItems="center">\n              <Grid item xs><Typography variant="subtitle1">Selected</Typography></Grid>\n              <Grid item><Chip size="small" color="primary" label={selected.name} /></Grid>\n            </Grid>\n          </Box>\n        </Grid>\n        { \n          selected.settings && React.createElement(selected.settings)\n        }\n        <MaterialButton\n          variant="contained"\n          color="default"\n        >\n          Delete\n        </MaterialButton>\n      </Grid>\n    </Box>\n  ) : null\n}\n')),Object(r.b)("p",null,"Now, we have to make our Delete button work. We can achieve this by using the ",Object(r.b)("inlineCode",{parentName:"p"},"delete")," action available from the ",Object(r.b)("inlineCode",{parentName:"p"},"useEditor")," hook."),Object(r.b)("p",null,"Also, it's important to note that not all nodes are deletable - if we try to delete an undeletable Node, it'll result in an error. Hence, it's good to make use of the ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"/craft.js/docs/api/helpers"}),"helper"),' methods which helps describe a Node. In our case, we would like to know if the currently selected Node is deletable before actually displaying the "Delete" button. We can access the helper methods via the ',Object(r.b)("inlineCode",{parentName:"p"},"node")," query in the ",Object(r.b)("inlineCode",{parentName:"p"},"useEditor")," hook."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{13,27-37}","{13,27-37}":!0}),'// components/SettingsPanel.js\n\nexport const SettingsPanel = () => {\n  const { actions, selected } } = useEditor((state, query) => {\n    const currentNodeId = state.events.selected;\n    let selected;\n\n    if ( currentNodeId ) {\n      selected = {\n        id: currentNodeId,\n        name: state.nodes[currentNodeId].data.name,\n        settings: state.nodes[currentNodeId].related && state.nodes[currentNodeId].related.settings,\n        isDeletable: query.node(currentNodeId).isDeletable()\n      };\n    }\n\n    return {\n      selected\n    }\n  });\n\n  return selected ? (\n    <Box bgcolor="rgba(0, 0, 0, 0.058823529411764705)" mt={2} px={2} py={2}>\n      <Grid container direction="column" spacing={0}>\n        ...\n        {\n          selected.isDeletable ? (\n            <MaterialButton\n              variant="contained"\n              color="default"\n              onClick={() => {\n                actions.delete(selected.id);\n              }}\n            >\n              Delete\n            </MaterialButton>\n          ) : null\n        }\n      </Grid>\n    </Box>\n  ) : null\n}\n')),Object(r.b)(i.c,{img:"tutorial/settings-panel.gif",mdxType:"Image"}),Object(r.b)("h3",{id:"topbar"},"Topbar"),Object(r.b)("p",null,"This is the last part of the editor that we have to take care of and then we're done! "),Object(r.b)("p",null,"First, we can get the editor's ",Object(r.b)("inlineCode",{parentName:"p"},"enabled")," state by passing in a collector function just like what we did before. Then, we can use the ",Object(r.b)("inlineCode",{parentName:"p"},"setOptions")," action to toggle the ",Object(r.b)("inlineCode",{parentName:"p"},"enabled")," state."),Object(r.b)("p",null,"Lastly, the ",Object(r.b)("inlineCode",{parentName:"p"},"useEditor")," hook also provides ",Object(r.b)("inlineCode",{parentName:"p"},"query")," methods which provide information based the editor'state. In our case,  we would like to get the current state of all the ",Object(r.b)("inlineCode",{parentName:"p"},"Nodes")," in a serialized form; we can do this by calling the ",Object(r.b)("inlineCode",{parentName:"p"},"serialize")," query method. "),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{4,7-9,16,25-27}","{4,7-9,16,25-27}":!0}),'// components/Topbar.js\nimport React from "react";\nimport { Box, FormControlLabel, Switch, Grid, Button as MaterialButton } from "@material-ui/core";\nimport { useEditor } from "@craftjs/core";\n\nexport const Topbar = () => {\n  const { actions, query, enabled } = useEditor((state) => ({\n    enabled: state.options.enabled\n  }));\n\n  return (\n    <Box px={1} py={1} mt={3} mb={1} bgcolor="#cbe8e7">\n      <Grid container alignItems="center">\n        <Grid item xs>\n          <FormControlLabel\n            control={<Switch checked={enabled} onChange={(_, value) => actions.setOptions(options => options.enabled = value)} />}\n            label="Enable"\n          />\n        </Grid>\n        <Grid item>\n          <MaterialButton \n            size="small" \n            variant="outlined" \n            color="secondary"\n            onClick={() => {\n              console.log(query.serialize())\n            }}\n          >\n              Serialize JSON to console\n          </MaterialButton>\n        </Grid>\n      </Grid>\n    </Box>\n  )\n};\n')),Object(r.b)(i.c,{img:"tutorial/topbar.gif",mdxType:"Image"}),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"We'll explore how to compress the JSON output and have the editor load from the serialised JSON in the ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"/r/docs/next/guides/save-load-state"}),"Save and Load")," guide.")),Object(r.b)("h2",{id:"you-made-it-"},"You made it \ud83c\udf89"),Object(r.b)("p",null,"We've made it to the end! Not too bad right? Hopefully, you're able to see the simplicity of building a fully working page editor with Craft.js."),Object(r.b)("p",null,"We do not need to worry about implementing the drag-n-drop system but rather simply focus on writing rules and attaching connectors to the desired elements."),Object(r.b)("p",null,"When it comes to writing the components themselves, it is the same as writing any other React component - you control how the components react to different editor events and how they are edited. "))}p.isMDXComponent=!0},207:function(e,n,t){"use strict";function o(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}t.d(n,"a",(function(){return o}))},208:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return u}));var o=t(0),a=t.n(o);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=a.a.createContext({}),d=function(e){var n=a.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=d(e.components);return a.a.createElement(c.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},m=a.a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(t),m=o,u=p["".concat(i,".").concat(m)]||p[m]||b[m]||r;return t?a.a.createElement(u,l(l({ref:n},c),{},{components:t})):a.a.createElement(u,l({ref:n},c))}));function u(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<r;c++)i[c]=t[c];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},209:function(e,n,t){"use strict";var o=t(0),a=t(48);n.a=function(){return Object(o.useContext)(a.a)}},210:function(e,n,t){"use strict";var o=t(0),a=t.n(o),r=function(e){var n=e.item,t=n[0],o=n.length>1&&"string"==typeof n[1]&&n[1],r=3==n.length?"string"==typeof n[2]&&n[2]:4==n.length&&"string"==typeof n[3]&&n[3],l=n.length>1&&Array.isArray(n[n.length-1])&&n[n.length-1];return a.a.createElement("li",{className:"api-item"},a.a.createElement("div",null,t&&a.a.createElement("code",{className:"api-title"},t),o&&a.a.createElement("strong",{className:"api-type"},o)),r&&a.a.createElement("div",{className:"api-description",dangerouslySetInnerHTML:{__html:r}}),l&&a.a.createElement(i,{items:l}))},i=function(e){var n=e.items;return a.a.createElement("ul",null,n&&n.map((function(e,n){return a.a.createElement(r,{item:e,key:n})})))},l=function(e){var n,t=e.type,o=e.title,r=void 0===o||o,i=e.noMargin,l=void 0===i||i;switch(t){case"hoc":n="Higher-Order Component";break;default:n=t[0].toUpperCase()+t.substring(1)}return a.a.createElement("div",{className:"badge-wrapper"},a.a.createElement("span",{className:"badge badge-"+t+" "+(r?"badge-title":"")+" "+(l?"badge-no-margin":"")},n))},s=t(209),c=function(e){var n=e.img,t=Object(s.a)().siteConfig.baseUrl;return a.a.createElement("div",{className:"img-wrapper"},a.a.createElement("div",null,a.a.createElement("header",null,a.a.createElement("div",null),a.a.createElement("div",null),a.a.createElement("div",null)),a.a.createElement("img",{src:t+"img/"+n})))};t.d(n,"a",(function(){return i})),t.d(n,"b",(function(){return l})),t.d(n,"b",(function(){})),t.d(n,"c",(function(){return c}))}}]);