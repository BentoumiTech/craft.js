(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{132:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return d}));var o=n(47),a=n(207),r=(n(0),n(208)),i=(n(210),{id:"user-components",title:"User Components"}),l={id:"version-0.1.0-beta.7/concepts/user-components",title:"User Components",description:"User Components are intended to be written just like any other React Component.",source:"@site/versioned_docs/version-0.1.0-beta.7/concepts/user-components.md",permalink:"/r/docs/concepts/user-components",version:"0.1.0-beta.7",sidebar:"version-0.1.0-beta.7/docs",previous:{title:"Nodes",permalink:"/r/docs/concepts/nodes"},next:{title:"Interacting with the Editor",permalink:"/r/docs/concepts/editor-components"}},c=[{value:"Connectors",id:"connectors",children:[]},{value:"Props manipulation",id:"props-manipulation",children:[]},{value:"Collecting Node&#39;s state",id:"collecting-nodes-state",children:[]},{value:"Default Props",id:"default-props",children:[]},{value:"Specify drag/drop rules",id:"specify-dragdrop-rules",children:[]},{value:"Related Components",id:"related-components",children:[]},{value:"Defining editable elements",id:"defining-editable-elements",children:[{value:"Linked nodes vs Child nodes",id:"linked-nodes-vs-child-nodes",children:[]}]}],s={rightToc:c};function d(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"User Components are intended to be written just like any other React Component. "),Object(r.b)("p",null,"Let's start with a simple Text component:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'const Text = ({text, fontSize}) => {\n  return (\n    <span contenteditable="true" style={{fontSize}}>{text}</span>\n  )\n}\n')),Object(r.b)("p",null,"Now, let's actually get the component to work with the editor. The ",Object(r.b)("inlineCode",{parentName:"p"},"useNode")," hook provides us with several information and methods related to the corresponding ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," that manages the component."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const { connectors: {connect, drag}, setProp, ...collected } = useNode((node) => {});\n")),Object(r.b)("p",null,"Additionally we can pass configuration values via the static ",Object(r.b)("inlineCode",{parentName:"p"},"craft")," property:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const Text = () => {...}\nText.craft = {\n  props: {},\n  rules: {\n    canDrag: () => true,\n    canMoveIn: () => true,\n    canMoveOut: () => true\n  },\n  related: {}\n}\n")),Object(r.b)("p",null,"We'll explore each of these values in the following sections."),Object(r.b)("h2",{id:"connectors"},"Connectors"),Object(r.b)("p",null,"The first thing we would want to do is to actually let Craft.js to manage the DOM for our component. "),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"connect"),": specifies the DOM that represents the User Component.  If the component's corresponding Node is a Canvas, then this also defines the area that is droppable."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"drag"),": specifies the DOM element that should be made draggable. When the user drags this element, it'll be considered as dragging the entire component, therefore moving the entire component to the drop location. This connector only takes effect if the component's corresponding node is a Canvas Node.")),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{17,18,21}","{17,18,21}":!0}),"const Container = ({children}) => {\n  const { connectors: {connect, drag} } = useNode();\n  return (\n    <div ref={dom => connect(drag(dom))}>\n      {children}\n    </div>\n  )\n}\n\nconst App = () => {\n  return (\n    <Editor resolvers={{Container}}>\n      <Frame>\n        <Element is={Container} canvas> // (i)\n          <Container> // (ii)\n            <h2>Hi</h2>\n          </Container>\n          <Element is={Container} canvas> // (iii)\n            <h2>Hi</h2>\n          </Element>\n        </Element>\n      </Frame>\n    </Editor>\n  )\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"i. ",Object(r.b)("inlineCode",{parentName:"li"},"Hero")," is being rendered with a Canvas Node, thus it defines a droppable region. However, since it is not a child of a Canvas Node, it is not draggable (the ",Object(r.b)("inlineCode",{parentName:"li"},"drag")," handler will not do anything)."),Object(r.b)("li",{parentName:"ul"},"ii. ",Object(r.b)("inlineCode",{parentName:"li"},"Hero")," is an immediate child of a Canvas Node; it is draggable."),Object(r.b)("li",{parentName:"ul"},"iii. ",Object(r.b)("inlineCode",{parentName:"li"},"Hero")," is an immediate child of a Canvas Node and is rendered with a Canvas Node - it is both draggable and droppable.")),Object(r.b)("h2",{id:"props-manipulation"},"Props manipulation"),Object(r.b)("p",null,"You've probably seen page editors where you could directly interact with the components and manipulate them. For instance, drag to resize an image or visually edit a text. This is easily achievable with Craft.js as well."),Object(r.b)("p",null,"Since components are managed by their corresponding ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," which contains information including the component's props, thus we can call the ",Object(r.b)("inlineCode",{parentName:"p"},"setProp")," method to update the prop values stored in the ",Object(r.b)("inlineCode",{parentName:"p"},"Node"),". In turn, this will re-render the component with its updated values."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const Text = ({text, fontSize}) => {\n  const { connectors: {connect, drag}, setProp } = useNode();\n\n  return (\n    <span ref={dom => connect(drag(dom))} style={{fontSize}} contentEditable={isClicked} onKeyUp={(e) => {\n        setProp(props => {\n          props.text = e.target.innerText;\n        })\n      }}>{text}\n    </span>\n  )\n}\n")),Object(r.b)("p",null,"In the above example, we have updated our ",Object(r.b)("inlineCode",{parentName:"p"},"span")," element to be content editable and added an event handler to update the ",Object(r.b)("inlineCode",{parentName:"p"},"text")," prop as the user visually enters in a new value."),Object(r.b)("h2",{id:"collecting-nodes-state"},"Collecting Node's state"),Object(r.b)("p",null,"The information stored in a corresponding ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," could be useful in helping you build more usable components. We can retrieve information from a ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," by passing a collector function to the ",Object(r.b)("inlineCode",{parentName:"p"},"useNode")," hook. Every time the values we retrieved via the collector function changes, our component will re-render. This is very much similar to Redux's ",Object(r.b)("inlineCode",{parentName:"p"},"connect")," pattern."),Object(r.b)("p",null,"For instance, let's say we would like to enable the content editable text from the previous section only when the user has actually clicked on our component: "),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const Text = ({text, fontSize}) => {\n  const { connectors: {connect, drag}, setProp, isClicked } = useNode((node) => ({\n    isClicked: node.events.selected\n  }));\n\n  return (\n    <span ref={dom => connect(drag(dom))} style={{fontSize}} contentEditable={isClicked} onKeyUp={(e) => {\n        setProp(props => {\n          props.text = e.target.innerText;\n        })\n      }}>{text}\n    </span>\n  )\n}\n")),Object(r.b)("h2",{id:"default-props"},"Default Props"),Object(r.b)("p",null,"While it's not necessary as we could simply define default parameters (e.g.: ES6 defaults) directly within our components, these default values will not actually be recorded into the component's corresponding ",Object(r.b)("inlineCode",{parentName:"p"},"Node"),", which could leave us with a lot of empty prop values when we wish to retrieve the ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," for a component when building other parts of our editor (eg: a Toolbar for editing a component's values)."),Object(r.b)("p",null,"To prevent that, we can explicitly specify default prop values via the ",Object(r.b)("inlineCode",{parentName:"p"},"craft.props")," like the following:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'const Text = ({text}) => { /** same as previous example **/ }\nHero.craft = {\n  props: {\n    text: "Hi there!"\n  }\n}\n')),Object(r.b)("h2",{id:"specify-dragdrop-rules"},"Specify drag/drop rules"),Object(r.b)("p",null,"You may want to restrict how your components are dragged or what goes in and out of your component. These rules can be specified in the static ",Object(r.b)("inlineCode",{parentName:"p"},"craft.rules"),"."),Object(r.b)("p",null,"Let us write a (pretty strange) rule for our Text component which users can only drag if they change the ",Object(r.b)("inlineCode",{parentName:"p"},"text"),' prop to "Drag": '),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'const Text = ({text}) => { /** same as the previous example **/ }\nText.craft = {\n  props: { /** same as the previous example **/ },\n  rules: {\n    canDrag: (node) => !!node.data.props.text == "Drag"\n  }\n}\n')),Object(r.b)("h2",{id:"related-components"},"Related Components"),Object(r.b)("p",null,"What happens if you need to design some component to complement our  user component? For instance, if we were planning on building a Toolbar somewhere in our page editor, we would like the Toolbar to display a bunch of text inputs to allow the user the edit the currently selected component. It would be great if we could retrieve a specific component that has all the relevant inputs for the user to edit the currently selected component."),Object(r.b)("p",null,"This is where related components become useful. These components share the same corresponding ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," as the actual user component, hence the ",Object(r.b)("inlineCode",{parentName:"p"},"useNode")," hook that we have been using all this while will be made available to these components as well. "),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'const Hero = ({text}) => { /** same as the previous example **/ }\nHero.craft = {\n  related: {\n    toolbar: HeroToolbarSettings\n  }\n}\n\nconst HeroToolbarSettings = () => {\n  const { setProp, text } = useNode((node) => ({\n    text: node.data.props.text\n  }));\n\n  return (\n    <div>\n      <h2>Hero settings</h2>\n      <input \n        type = "text" \n        value={text} \n        onChange={e => \n          setProp(prop => prop.text = e.target.value) \n        }\n       />\n    </div>\n  )\n}\n')),Object(r.b)("p",null,"Now, let's say we have a Toolbar component somewhere in our editor. We can easily retrieve the related component as such:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const Toolbar = () => {\n  const { selectededNodeId, toolbarSettings } = useEditor((state) => ({\n    selectededNodeId : state.event.selected,\n    toolbarSettings:  state.nodes[state.events.selected].related.toolbar\n  }));\n  return (\n    <div>\n      <h2>My Awesome Toolbar</h2>\n      {\n        selectededNodeId && toolbarSettings ? \n          React.createElement(toolbarSettings)\n        : null\n      }\n    </div>\n  )\n}\n\n")),Object(r.b)("h2",{id:"defining-editable-elements"},"Defining editable elements"),Object(r.b)("p",null,"Let's say we're building a Hero user component:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const Hero = ({background, title}) => {\n  return (\n    <div style={{ background }}>\n      <span>{title}</span>\n      <section>\n        <h3>I need some coffee to continue writing this</h3>\n      </section>\n    </div>\n  )\n}\n")),Object(r.b)("p",null,"Your first instinct might be to simply just use the Text component directly:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const Hero = ({background, title}) => {\n  return (\n    <div style={{ background }}>\n      <Text text={title} />\n      <section>... </section>\n    </div>\n  )\n}\n")),Object(r.b)("p",null,"But this won't really work - the Text Component will not have its own Node. Instead, it will still be a part of the Hero's Node. So for example, inside the Text Component, if we call ",Object(r.b)("inlineCode",{parentName:"p"},'setProps(props => props.text = "...")'),", it will actually be editing the props of ",Object(r.b)("inlineCode",{parentName:"p"},"Hero")," (in this case it will be adding a new prop ",Object(r.b)("inlineCode",{parentName:"p"},"text")," to Hero, which is not consumed by Hero anyway). Essentially, this means you can't have your users to click on the Text component and have them edit the text independently. "),Object(r.b)("p",null,"Remember how the ",Object(r.b)("inlineCode",{parentName:"p"},"<Element / >")," component was used to define/configure Nodes? Well, we can use that here to define a new Node for our Text component:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'const Hero = ({background, title}) => {\n  return (\n    <div style={{ background }}>\n      <Element id="title_text" is={Text} text={title} />\n      <section>\n        <h3>I need some coffee to continue writing this</h3>\n      </section>\n    </div>\n  )\n}\n')),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"You must specify the ",Object(r.b)("inlineCode",{parentName:"p"},"id")," prop when defining new Nodes with ",Object(r.b)("inlineCode",{parentName:"p"},"<Element />")," inside a User Component")),Object(r.b)("p",null,"We call these linked nodes since they are linked to another Node via an arbitary ",Object(r.b)("inlineCode",{parentName:"p"},"id"),". In this case, the ",Object(r.b)("inlineCode",{parentName:"p"},"Text")," node is linked to ",Object(r.b)("inlineCode",{parentName:"p"},"Hero"),'\'s node via its "title_text" id.'),Object(r.b)("h3",{id:"linked-nodes-vs-child-nodes"},"Linked nodes vs Child nodes"),Object(r.b)("p",null,"It's important to know that this is not a child Node like what we have seen all the while before this. A child Node is passed and rendered in its parent's ",Object(r.b)("inlineCode",{parentName:"p"},"children")," prop whereas this is directly part of its parent's render method. "),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{4}","{4}":!0}),'const Hero = ({background, title}) => {\n  return (\n    <div style={{ background }}>\n      <Element id="title" is={Text} text={title} /> // Linked node\n      ...\n    </div>\n  )\n}\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"{5,11}","{5,11}":!0}),"const Container = ({background, title, children}) => {\n  return (\n    <div style={{ background }}>\n      ...\n      {children}\n    </div>\n  )\n}\n\n<Container>\n  <h2>Text</h2> // Child Node\n</Container>\n")))}d.isMDXComponent=!0},207:function(e,t,n){"use strict";function o(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}n.d(t,"a",(function(){return o}))},208:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var o=n(0),a=n.n(o);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=a.a.createContext({}),d=function(e){var t=a.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=d(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},b=a.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=d(n),b=o,m=p["".concat(i,".").concat(b)]||p[b]||u[b]||r;return n?a.a.createElement(m,l(l({ref:t},s),{},{components:n})):a.a.createElement(m,l({ref:t},s))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=b;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<r;s++)i[s]=n[s];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},209:function(e,t,n){"use strict";var o=n(0),a=n(48);t.a=function(){return Object(o.useContext)(a.a)}},210:function(e,t,n){"use strict";var o=n(0),a=n.n(o),r=function(e){var t=e.item,n=t[0],o=t.length>1&&"string"==typeof t[1]&&t[1],r=3==t.length?"string"==typeof t[2]&&t[2]:4==t.length&&"string"==typeof t[3]&&t[3],l=t.length>1&&Array.isArray(t[t.length-1])&&t[t.length-1];return a.a.createElement("li",{className:"api-item"},a.a.createElement("div",null,n&&a.a.createElement("code",{className:"api-title"},n),o&&a.a.createElement("strong",{className:"api-type"},o)),r&&a.a.createElement("div",{className:"api-description",dangerouslySetInnerHTML:{__html:r}}),l&&a.a.createElement(i,{items:l}))},i=function(e){var t=e.items;return a.a.createElement("ul",null,t&&t.map((function(e,t){return a.a.createElement(r,{item:e,key:t})})))},l=function(e){var t,n=e.type,o=e.title,r=void 0===o||o,i=e.noMargin,l=void 0===i||i;switch(n){case"hoc":t="Higher-Order Component";break;default:t=n[0].toUpperCase()+n.substring(1)}return a.a.createElement("div",{className:"badge-wrapper"},a.a.createElement("span",{className:"badge badge-"+n+" "+(r?"badge-title":"")+" "+(l?"badge-no-margin":"")},t))},c=n(209),s=function(e){var t=e.img,n=Object(c.a)().siteConfig.baseUrl;return a.a.createElement("div",{className:"img-wrapper"},a.a.createElement("div",null,a.a.createElement("header",null,a.a.createElement("div",null),a.a.createElement("div",null),a.a.createElement("div",null)),a.a.createElement("img",{src:n+"img/"+t})))};n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return l})),n.d(t,"b",(function(){})),n.d(t,"c",(function(){return s}))}}]);